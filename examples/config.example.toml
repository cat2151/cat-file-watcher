# Example configuration for cat-file-watcher
# This file demonstrates how to configure file monitoring and command execution

# Default interval for checking files
# Supports time format: "1s" (1 second), "2m" (2 minutes), "3h" (3 hours), "0.5s" (0.5 seconds)
# Also supports old format: integer milliseconds (e.g., 1000 for 1 second) for backward compatibility
# Default: "1s" (1 second)
default_interval = "1s"

# Interval for checking the config file itself for changes
# When the config file changes, it will be automatically reloaded
# Supports same time format as default_interval
# Default: "1s" (1 second)
config_check_interval = "1s"

# Optional: Load external TOML files containing [files] sections
# This allows you to organize your file configurations into groups
# You can quickly enable/disable entire groups by commenting/uncommenting the path
# Paths can be relative (to this config file) or absolute
# External files can ONLY contain [files] sections - other sections will cause an error
# external_files = [
#     "monitoring-group1.toml",
#     "monitoring-group2.toml",
#     "/absolute/path/to/monitoring-group3.toml"
# ]

# Optional: Log file path for command execution logging
# When specified, files with enable_log=true will log command execution details here
# log_file = "command_execution.log"

# Optional: Error log file path for error and exception logging
# When specified, all errors and exceptions will be logged here with timestamps and stack traces
# This implements a fail-fast system that logs errors before re-raising or exiting
# error_log_file = "error.log"

# Optional: Suppression log file path for process suppression logging
# When specified, logs when command execution is suppressed due to matching processes
# Useful for detecting regex pattern mistakes in suppress_if_process settings
# Log includes: timestamp, process pattern regex, and the actual matched process name
# suppression_log_file = "suppression.log"

# Optional: Define time periods for file monitoring
# Files can specify a time_period to only be monitored during certain hours
# Time periods support spanning across midnight (e.g., 23:00-01:00)
[time_periods]
# Business hours: 9 AM to 5 PM
business_hours = { start = "09:00", end = "17:00" }

# After hours: 6 PM to 8 AM (spans midnight)
after_hours = { start = "18:00", end = "08:00" }

# Night shift: 11 PM to 1 AM (spans midnight)
night_shift = { start = "23:00", end = "01:00" }

# Midnight transition example from requirements: 23:59 to 00:01
midnight_window = { start = "23:59", end = "00:01" }

[files]
# Each entry defines a file or directory to monitor and a command to execute when it changes
# Directories: Command executes when directory modification time changes (files added/removed/etc.)
# Optional: specify 'interval' with time format ("1s", "2m", "3h", "0.5s") to override the default
#           Also supports old format: integer milliseconds for backward compatibility
# Optional: specify 'suppress_if_process' with a regex pattern to skip command execution
#           when a process matching the pattern is running
# Optional: specify 'time_period' to only monitor during that time period
# Optional: specify 'enable_log = true' to log command execution to the log file (default: false)
# Optional: specify 'cwd' to change the working directory before executing the command

# Example 1: Monitor a text file and display a message (uses default interval)
# "example.txt" = { command = "echo 'example.txt has been modified!'" }

# Example 2: Monitor a Python file and run tests (check every 2 seconds)
# "my_script.py" = { command = "python -m pytest tests/", interval = "2s" }

# Example 3: Monitor a config file and reload a service (check every 5 seconds)
# "/etc/myapp/config.ini" = { command = "systemctl reload myapp", interval = "5s" }

# Example 4: Monitor a log file frequently and send a notification (check every 500ms)
# "app.log" = { command = "notify-send 'Log Updated' 'app.log has new entries'", interval = "0.5s" }

# Example 5: Monitor a document and create a backup (uses default interval)
# "document.txt" = { command = "cp document.txt document.txt.bak" }

# Example 6: Monitor a directory for changes (files added/removed/modified)
# Triggers when files are added, removed, or renamed in the directory
# "src/" = { command = "echo 'Source directory changed!'", interval = "1s" }

# Example 7: Monitor a directory and rebuild on changes (check every 2 seconds)
# "/path/to/project/src/" = { command = "make build", interval = "2s" }

# Example 8: Only run build when editor is not running (process suppression)
# Suppress command execution if a process matching the regex pattern is running
# This is useful to avoid rebuilding while you're actively editing
# "src/main.py" = { command = "make build", suppress_if_process = "vim|emacs|code" }

# Example 9: Only sync when specific sync process is not running
# "data.json" = { command = "rsync -av data.json backup/", suppress_if_process = "rsync" }

# Example 10: Monitor only during business hours
# "work_report.txt" = { command = "python generate_report.py", time_period = "business_hours" }

# Example 11: Monitor only during after hours (night time)
# "batch_data.csv" = { command = "./process_batch.sh", time_period = "after_hours" }

# Example 12: Combine time period with process suppression
# "code.py" = { command = "python -m pytest", time_period = "business_hours", suppress_if_process = "vim|code" }

# Example 13: Enable logging for a critical file (requires log_file to be set globally)
# "important.txt" = { command = "backup.sh", enable_log = true }

# Example 14: Monitor with logging and custom interval (check every 2 seconds)
# "config.json" = { command = "validate_config.sh", interval = "2s", enable_log = true }

# Example 15: Process health monitoring without file watching (empty filename)
# Executes command every second (default_interval) without monitoring any file
# Useful for process health checks, auto-restart, or periodic tasks
# "" = { command = "echo 'Health check at' $(date)" }

# Example 16: Auto-restart process when it's not running
# Using empty filename with suppress_if_process for process health monitoring
# Command only executes when the process is NOT running (suppressed when running)
# "" = { command = "./start_myapp.sh", suppress_if_process = "myapp", interval = "5s" }

# Example 17: Periodic cleanup task (runs every 10 seconds)
# "" = { command = "find /tmp -type f -mtime +7 -delete", interval = "10s" }

# Example 18: Execute command in a different directory (cwd)
# Run build script from the build directory
# "src/main.py" = { command = "make", cwd = "./build" }

# Example 19: Execute command with relative paths using cwd
# Compile code in the project directory
# "lib/module.c" = { command = "gcc -c module.c -o module.o", cwd = "./lib" }


