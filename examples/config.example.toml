# Example configuration for cat-file-watcher
# This file demonstrates how to configure file monitoring and command execution

# Enable timestamp display in print statements
# When enabled, all console output will be prefixed with [YYYY-MM-DD HH:MM:SS]
# Default: true (timestamps are shown)
# enable_timestamp = true

# Default interval for checking files
# Supports time format: "500ms" (500 milliseconds), "1s" (1 second), "2m" (2 minutes), "3h" (3 hours), "0.5s" (0.5 seconds)
# Default: "1s" (1 second)
default_interval = "1s"

# Interval for checking the config file itself for changes
# When the config file changes, it will be automatically reloaded
# Supports same time format as default_interval
# Default: "1s" (1 second)
config_check_interval = "1s"

# Optional: Load external TOML files containing [files] sections
# This allows you to organize your file configurations into groups
# You can quickly enable/disable entire groups by commenting/uncommenting the path
# Paths can be relative (to this config file) or absolute
# External files can ONLY contain [files] sections - other sections will cause an error
# external_files = [
#     "monitoring-group1.toml",
#     "monitoring-group2.toml",
#     "/absolute/path/to/monitoring-group3.toml"
# ]

# Optional: Log file path for command execution logging
# When specified, files with enable_log=true will log command execution details here
# log_file = "command_execution.log"

# Optional: Error log file path for error and exception logging
# When specified, all errors and exceptions will be logged here with timestamps and stack traces
# This implements a fail-fast system that logs errors before re-raising or exiting
# error_log_file = "error.log"

# Optional: Suppression log file path for process suppression logging
# When specified, logs when command execution is suppressed due to matching processes
# Useful for detecting regex pattern mistakes in suppress_if_process settings
# Log includes: timestamp, process pattern regex, and the actual matched process name
# suppression_log_file = "suppression.log"

# Optional: Define time periods for file monitoring
# Files can specify a time_period to only be monitored during certain hours
# Time periods support spanning across midnight (e.g., 23:00-01:00)
[time_periods]
# Business hours: 9 AM to 5 PM
business_hours = { start = "09:00", end = "17:00" }

# After hours: 6 PM to 8 AM (spans midnight)
after_hours = { start = "18:00", end = "08:00" }

# Night shift: 11 PM to 1 AM (spans midnight)
night_shift = { start = "23:00", end = "01:00" }

# Midnight transition example from requirements: 23:59 to 00:01
midnight_window = { start = "23:59", end = "00:01" }

# NOTE: The [[files]] section uses array of tables format
# This allows multiple entries with the same path (useful for empty path entries)

# Example 1: Monitor a text file and display a message (uses default interval)
# [[files]]
# path = "example.txt"
# command = "echo 'example.txt has been modified!'"

# Example 2: Monitor a Python file and run tests (check every 2 seconds)
# [[files]]
# path = "my_script.py"
# command = "python -m pytest tests/"
# interval = "2s"

# Example 3: Monitor a config file and reload a service (check every 5 seconds)
# [[files]]
# path = "/etc/myapp/config.ini"
# command = "systemctl reload myapp"
# interval = "5s"

# Example 4: Monitor a log file frequently and send a notification (check every 500ms)
# [[files]]
# path = "app.log"
# command = "notify-send 'Log Updated' 'app.log has new entries'"
# interval = "500ms"

# Example 5: Monitor a document and create a backup (uses default interval)
# [[files]]
# path = "document.txt"
# command = "cp document.txt document.txt.bak"

# Example 6: Monitor a directory for changes (files added/removed/modified)
# Triggers when files are added, removed, or renamed in the directory
# [[files]]
# path = "src/"
# command = "echo 'Source directory changed!'"
# interval = "1s"

# Example 7: Monitor a directory and rebuild on changes (check every 2 seconds)
# [[files]]
# path = "/path/to/project/src/"
# command = "make build"
# interval = "2s"

# Example 8: Only run build when editor is not running (process suppression)
# Suppress command execution if a process matching the regex pattern is running
# This is useful to avoid rebuilding while you're actively editing
# [[files]]
# path = "src/main.py"
# command = "make build"
# suppress_if_process = "vim|emacs|code"

# Example 9: Only sync when specific sync process is not running
# [[files]]
# path = "data.json"
# command = "rsync -av data.json backup/"
# suppress_if_process = "rsync"

# Example 10: Monitor only during business hours
# [[files]]
# path = "work_report.txt"
# command = "python generate_report.py"
# time_period = "business_hours"

# Example 11: Monitor only during after hours (night time)
# [[files]]
# path = "batch_data.csv"
# command = "./process_batch.sh"
# time_period = "after_hours"

# Example 12: Combine time period with process suppression
# [[files]]
# path = "code.py"
# command = "python -m pytest"
# time_period = "business_hours"
# suppress_if_process = "vim|code"

# Example 13: Enable logging for a critical file (requires log_file to be set globally)
# [[files]]
# path = "important.txt"
# command = "backup.sh"
# enable_log = true

# Example 14: Monitor with logging and custom interval (check every 2 seconds)
# [[files]]
# path = "config.json"
# command = "validate_config.sh"
# interval = "2s"
# enable_log = true

# Example 15: Process health monitoring without file watching (empty path)
# Executes command every second (default_interval) without monitoring any file
# Useful for process health checks, auto-restart, or periodic tasks
# [[files]]
# path = ""
# command = "echo 'Health check at' $(date)"

# Example 16: Auto-restart process when it's not running
# Using empty path with suppress_if_process for process health monitoring
# Command only executes when the process is NOT running (suppressed when running)
# [[files]]
# path = ""
# command = "./start_myapp.sh"
# suppress_if_process = "myapp"
# interval = "5s"

# Example 17: Periodic cleanup task (runs every 10 seconds)
# [[files]]
# path = ""
# command = "find /tmp -type f -mtime +7 -delete"
# interval = "10s"

# Example 18: Execute command in a different directory (cwd)
# Run build script from the build directory
# [[files]]
# path = "src/main.py"
# command = "make"
# cwd = "./build"

# Example 19: Execute command with relative paths using cwd
# Compile code in the project directory
# [[files]]
# path = "lib/module.c"
# command = "gcc -c module.c -o module.o"
# cwd = "./lib"

# Example 20: Execute command without stealing focus (no_focus) - Windows only
# When no_focus is enabled, commands are launched asynchronously (does not wait for completion)
# Windows: Shows the window without activating it (SW_SHOWNOACTIVATE) to prevent focus stealing
# The window is visible but does not take focus from the current foreground window
# Non-Windows: Falls back to normal execution with a warning
# Commands are parsed with shlex.split() for proper argument handling (quotes, escapes, etc.)
# Note: Shell features (pipes, redirects, env vars) are not available in this mode
# [[files]]
# path = "data.txt"
# command = "python process.py data.txt"
# no_focus = true

# Example 21: Process termination without file watching (terminate_if_process)
# Monitors and terminates processes matching the regex pattern(s)
# IMPORTANT: Can ONLY be used with empty path ("") and NO command field
# Safety check per pattern: Only terminates when exactly ONE process matches the pattern
# Warns and does NOT terminate when multiple processes match the same pattern
# Can specify a single pattern as a string OR multiple patterns as an array
# When using an array, each pattern is evaluated independently with its own safety check
# Useful for scheduled process termination during specific time periods
# [[files]]
# path = ""
# terminate_if_process = "unwanted_process"  # Single pattern
# interval = "60s"
#
# # Or use an array for multiple patterns (each pattern is checked independently):
# [[files]]
# path = ""
# terminate_if_process = ["process1\\.exe", "process2\\.exe", "process3\\.exe"]
# interval = "60s"
# # If process1.exe has 1 instance → terminated
# # If process2.exe has 2+ instances → warning, NOT terminated (safety check)
# # If process3.exe has 0 instances → no action

# Example 22: Terminate process only during specific time period
# Check every minute and terminate matching process only during night shift
# [[files]]
# path = ""
# terminate_if_process = "batch_cleanup"
# interval = "60s"
# time_period = "night_shift"

# Example 23: Monitor and terminate rogue process every 5 minutes
# [[files]]
# path = ""
# terminate_if_process = "memory_hog_app"
# interval = "5m"

# Example 24: Terminate process by window title (Windows only)
# Finds windows matching the regex pattern and terminates the owning process
# IMPORTANT: Can ONLY be used with empty path ("") and NO command field
# Safety check per pattern: Only terminates when exactly ONE window matches the pattern
# Uses Win32 APIs: EnumWindows, GetWindowText, GetWindowThreadProcessId
# Useful for terminating applications that cannot be identified by process name alone
# [[files]]
# path = ""
# terminate_if_window_title = "Untitled - Notepad"  # Single pattern
# interval = "60s"
#
# # Or use an array for multiple patterns (each pattern is checked independently):
# [[files]]
# path = ""
# terminate_if_window_title = ["My App - Instance.*", "Test Window"]
# interval = "60s"

# Example 25: Multiple empty path entries for different periodic tasks
# With the new array format, you can have multiple entries with empty paths
# [[files]]
# path = ""
# command = "echo 'Task 1' >> /tmp/task1.log"
# interval = "10s"
#
# [[files]]
# path = ""
# command = "echo 'Task 2' >> /tmp/task2.log"
# interval = "20s"

# ==================== [[commands]] Section ====================
# The [[commands]] section is syntactic sugar for [[files]] entries with empty path
# It reduces cognitive load by making it clear these are periodic commands, not file monitors
# Key difference: 'path' field is FORBIDDEN in [[commands]] (will cause an error)

# Example 24: Periodic command execution using [[commands]] section
# This is equivalent to [[files]] with path="" but clearer in intent
# [[commands]]
# command = "echo 'Periodic task' >> /tmp/periodic.log"
# interval = "10s"

# Example 25: Multiple periodic commands with different intervals
# [[commands]]
# command = "python /path/to/cleanup.py"
# interval = "1m"
#
# [[commands]]
# command = "./backup.sh"
# interval = "1h"

# Example 26: Command with process suppression
# Only execute when the specified process is NOT running
# [[commands]]
# command = "./start_myapp.sh"
# suppress_if_process = "myapp"
# interval = "5s"

# Example 27: Command with time period restriction
# Only run during business hours
# [[commands]]
# command = "python generate_report.py"
# interval = "30s"
# time_period = "business_hours"

# ==================== [[processes]] Section ====================
# The [[processes]] section is syntactic sugar for process monitoring/termination
# It reduces cognitive load by making it clear these are process-related tasks
# Key differences: 
#   - 'path' field is FORBIDDEN in [[processes]] (will cause an error)
#   - 'command' field is FORBIDDEN in [[processes]] (will cause an error)
# This section is specifically for terminate_if_process functionality

# Example 28: Process termination using [[processes]] section
# This is equivalent to [[files]] with path="" and terminate_if_process
# [[processes]]
# terminate_if_process = "unwanted_process"
# interval = "60s"

# Example 29: Multiple process monitors
# [[processes]]
# terminate_if_process = "memory_hog"
# interval = "5m"
#
# [[processes]]
# terminate_if_process = "rogue_app"
# interval = "1m"

# Example 30: Process termination with time period
# Only terminate during night shift hours
# [[processes]]
# terminate_if_process = "batch_cleanup"
# interval = "60s"
# time_period = "night_shift"


